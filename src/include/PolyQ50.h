/*-
 * Copyright (c) 2016 Rozhuk Ivan <rim@vedapro.ru>
 * All rights reserved.
 *
 *
 * Author: Rozhuk Ivan <rozhuk.im@gmail.com>
 *
 *
 */

#ifndef POLYQ50_H
#define POLYQ50_H


#ifndef _WINDOWS
#	include <sys/param.h>
#	ifdef __linux__ /* Linux specific code. */
#		define _GNU_SOURCE /* See feature_test_macros(7) */
#		define __USE_GNU 1
#	endif /* Linux specific code. */
#	include <sys/types.h>
#	ifdef _KERNEL
#		include <sys/systm.h>
#	else
#		include <string.h> /* memcpy, memmove, memset... */
#		include <inttypes.h>
#	endif
#	define polyq50_print(__fmt, args...)	fprintf(stdout, (__fmt), ##args)
#else
#	include <stdlib.h>
#	include <string.h> /* memcpy, memmove, memset... */
#	include <stdint.h>
#	define uint8_t		unsigned char
#	define uint32_t		DWORD
#	define uint64_t		DWORDLONG
#	define size_t		SIZE_T
#	define polyq50_print()
#endif

#define POLYQ50_REVERSE_BITS		1

typedef __uint128_t			uint128_t;
//#define POLYQ50_MASK			0x0003ffffffffffff
#define POLYQ50_MASK			((~((uint64_t)0)) >> (64 - 50))
#define POLYQ50_OFFSET			27
#define POLYQ50_MOD			((((uint64_t)1) << 50) - POLYQ50_OFFSET)
#define POLYQ50_MARKER			((((uint64_t)1) << 50) - (POLYQ50_OFFSET + 1))
#define POLYQ50_BITS2BYTES(__bits_cnt)	(((__bits_cnt) + 7) >> 3)

/* interpret four 8 bit unsigned integers as a 56 bit unsigned integer in little endian */
#define U8_8TO56_LITTLE(__ptr)	(					\
	(((uint64_t)(((uint8_t*)__ptr)[0]))      ) |			\
	(((uint64_t)(((uint8_t*)__ptr)[1])) <<  8) |			\
	(((uint64_t)(((uint8_t*)__ptr)[2])) << 16) |			\
	(((uint64_t)(((uint8_t*)__ptr)[3])) << 24) |			\
	(((uint64_t)(((uint8_t*)__ptr)[4])) << 32) |			\
	(((uint64_t)(((uint8_t*)__ptr)[5])) << 40) |			\
	(((uint64_t)(((uint8_t*)__ptr)[6])) << 48))
/* store a 56 bit unsigned integer as four 8 bit unsigned integers in little endian */
static inline void
U56TO8_LITTLE(uint8_t *p, uint64_t v) {
	p[0] = (uint8_t)(v      );
	p[1] = (uint8_t)(v >>  8);
	p[2] = (uint8_t)(v >> 16);
	p[3] = (uint8_t)(v >> 24);
	p[4] = (uint8_t)(v >> 32);
	p[5] = (uint8_t)(v >> 40);
	p[6] = (uint8_t)(v >> 48);
}


#ifdef POLYQ50_REVERSE_BITS

/* 01001111 -> 11110010  */
static inline uint64_t
polyq50_rev64(uint64_t val) {
	register uint64_t x = val;

	x = ((x >>  1) & 0x5555555555555555) | ((x & 0x5555555555555555) <<  1);
	x = ((x >>  2) & 0x3333333333333333) | ((x & 0x3333333333333333) <<  2);
	x = ((x >>  4) & 0x0f0f0f0f0f0f0f0f) | ((x & 0x0f0f0f0f0f0f0f0f) <<  4);
	x = ((x >>  8) & 0x00ff00ff00ff00ff) | ((x & 0x00ff00ff00ff00ff) <<  8);
	x = ((x >> 16) & 0x0000ffff0000ffff) | ((x & 0x0000ffff0000ffff) << 16);
	x = ((x >> 32) | (x << 32));

	return (x);
}
#define POLYQ50_REV(__val)		(polyq50_rev64((__val)) >> (64 - 50))

#else

#define POLYQ50_REV(__val)		((__val) & POLYQ50_MASK)

#endif


#define POLYQ50_GET_BLK50(__buf, __off)					\
    POLYQ50_REV(U8_8TO56_LITTLE((__buf) + ((__off) >> 3)) >> ((__off) & 0x7))



static inline uint128_t
polyq50_mod(uint128_t val) {

#if 0
	if (val > POLYQ50_MOD) {
		val = (val % POLYQ50_MOD);
	} else if (val == POLYQ50_MOD) {
		val = 0;
	}
#else
	val = (val % POLYQ50_MOD);
#endif
	return (val);
}

static inline int
polyq50_mac(const uint8_t *buf, size_t buf_size,
    const uint8_t *key, uint8_t *result) {
	size_t i, offset, bkl_cnt;
	uint64_t key64, msg64;
	uint128_t res;

	if (NULL == buf || 0 == buf_size || NULL == key ||
	    NULL == result)
		return (EINVAL);
	key64 = POLYQ50_REV(U8_8TO56_LITTLE(key));
	buf_size *= 8; /* Bytes count to bits count. */
	bkl_cnt = (buf_size / 50);
	offset = (buf_size % 50);
	res = 1;

	/* First block. */
	msg64 = U8_8TO56_LITTLE(buf);
	msg64 = (msg64 << (50 - offset));
	msg64 = POLYQ50_REV(msg64);
	if (msg64 > POLYQ50_MARKER) {
		res = polyq50_mod((key64 + POLYQ50_MARKER));
		res = polyq50_mod(((res * key64) + (msg64 - POLYQ50_OFFSET)));
	} else {
		res = polyq50_mod((key64 + msg64));
	}

	/* Other blocks. */
	for (i = 0; i < bkl_cnt; i ++, offset += 50) {
		msg64 = POLYQ50_GET_BLK50(buf, offset);
		if (msg64 > POLYQ50_MARKER) {
			res = polyq50_mod(((res * key64) + POLYQ50_MARKER));
			res = polyq50_mod(((res * key64) + (msg64 - POLYQ50_OFFSET)));
		} else {
			res = polyq50_mod(((res * key64) + msg64));
		}
	}

	key64 = (uint64_t)res; /* Zero key, 128->64. */
	key64 = POLYQ50_REV(key64);
	U56TO8_LITTLE(result, key64);

	return (0);
}



#ifdef POLYQ50_SELF_TEST

#define POLYQ50_TEST_LEN 2048


typedef struct polyq50_test1_vectors_s {
	uint8_t *msg;
	size_t	msg_size;
	uint8_t	*key;
	uint8_t	*result;
} polyq50_tst1v_t, *polyq50_tst1v_p;

static polyq50_tst1v_t polyq50_tst1v[] = {
	{ /* 0. From VedaPro int */
		/*.msg =*/ 	(uint8_t*)"110011011100011001110111101011100100111111100101000001100101100010000000110110111010110010110011110111100011111101001100100111100100111011100011111111101111100111000111100001000011001010010010100010101101010010010100100010000110101100111001011101100100110101101100110111000100000101111110111110011010110100000010100110000010001111101101101010110001010000101111111101101000010001100100000000110111111000111100110001011101001011101101011111100001000000111000011101010011111100010001110111100011001011000011001110111011000000101001010100101011010010000000101000000000101001100100110011001110001001011101001000000000000011010111110101011111001001100001001111111010011010111001100110010110111111011001001001000011011100110100101111011011011011001101011011100100110010010111101000000100101001011110011110111111010101111001100110100100111011101100111000110111011001001011000001101101001100100000101111011101100111111100110111101110010000001000101000110100011011011010001000110100111111100110111010100010011010100001000011100010011111011001101011100011001010111100000101001011100010101111110101000110000010110000110011100100110111110000011101010101011111100110110100000110011110000100111001100100001101110101001110110011110100101111011000010001100101111101111001100011110111111101100101111001000100110111000100000001110011110110111111001001101101111100011111111101010100100001001100100011011001100101100011010111100100000000100101011111000110010000100011001101000001110001001001000011111101000001100110010000001111000100011011111010010101110101010110101001101101100001000000110001101111100001000111000000110110111111110111111100000111000001001000111111000011000000110000101101011100001110111100000111110110000011111010001110101011110101100110110001111011001011000111000100010010010010101011000110000110001110001110101010011010101110110110001010100000111111101001001010000011101111001001100010110111010010110111011001100001011010101100101100111111101110",
		/*.msg_size =*/		1944,
		/*.key =*/ 	(uint8_t*)"10001010111101011010010011100110100001101101100011",
		/*.result =*/ 	(uint8_t*)"01101101111010111111011100111111010000001000110100",
	}, { /* 1. From VedaPro int */
		/*.msg =*/ 	(uint8_t*)"101010111010110111101110000100001010111011111110000100010001001101111100111011010111111111100011001010100010011101011100011110000111111110011101111000101010100110011000100010001001100110011101000110111101101110001110100000110111110101111110111101011000001001111111010010111001111001100110001100110110010011000101111110110011000111100010011100110000110101000110001110010101010100111100010101001001010100100101011110001101000001000000101001110001110010010010100010001001010011000000110111101110010011000101110010111011110110011111010011011001111111110001110001000100101100101000000110111000110000000101001010100011001001111010101000110101001000110100010011100010100100010100000001111100011111010100100101110010000011000111010111101111010001000010000001111110011100111101110000010111111010010010100000010110001010011111111101101111001011101001100101000111110111110111110010101100010111111111101001101110100001100001011011011011001100011001100010011010000000011000010110100100001111011000111110100011111010100100111000101011011011101100010001000000000010101010011001001101010100111000000101100111010100000111100011111000000111000110000011001001001100001110011110001110101000011110111100101111000011101111001011000000000000100110011000001011010001101010001011110100100010001000100010111010000010000010111000010000000000011001100101000100100111110111111101011000000001101111110000111001110111011101000001001110100100010111100111000001001111110111111101110111000100010011011111010100100000111000101010100110011001101101001001001000001000111110000100101100010101100000110111111001100011110111000001100000010101100000011111111001001100011111000100010010111110110110111111001000101111111001010101010101111101100000000101111000010110100111101110001000100111010101011110111001000001000011000101100110011000110001100111011001000110000011111011101100111011101001011101001001010110010111100011010001111001001101001100100101011100110111110110101011001010000111",
		/*.msg_size =*/		1944,
		/*.key =*/ 	(uint8_t*)"01011010110011010101110101110111011010001000101000",
		/*.result =*/ 	(uint8_t*)"10100101100001000111000011010110111011010011100101",
	}, { /* 2. From VedaPro int */
		/*.msg =*/ 	(uint8_t*)"010011110011101011011101101111001111001011000101010000101011111001111110011001011100000100000100101011111101110010010011100100000101101001011011001010100111110101010000000100111111010000001111001111001000010011111110110110100001001100110010101110100001110101111100010100100011010110111110000000101111011001100001010101110011101010110110101100101011010101000001010000011010011100010110010110101101010111011100010011110001000100100010001111001001111110101111111001001110101000101111100010100000101010110111111111110011110101011111111000100101010111010111001010000101111101101000110000111011111111111001000111101000101110110110101000010100101100100011011111110010011010011111110010111110110101110000101001011011110111100010111001110001110000000101100110111110000011110010000111010100000001101000100110001000001010111101111000011110010000101011010001011010110100000001101001001000000111100110000010100100010110110001100001001110000110101011001100101010000011001001100100100100011000011111111011100110101111110110001000101011001010010010111101010000001010111010100100101001001110000111001001011100011001000110011011001101100011000111000111000010101110000010110011101110010111101011111100011110100110101010011111000100101010000110010101000100100111011011001010011100010010110100011110110101000000100010000100000001111110101101011010011111000010010011010100110010000101110111101100000100010100001100001011010001100111011011101001011110010001111010011110101001010111001011100000100001010101111101111001110110100101100010010111100010111011001110000101110011100100000011100110000100011000001110100001110011001011000100101011111010001010010111100101010100100000001001010011110000100111111000100110010001011000011001011011100010011100000100001000111000100001000100010100010000010011101100101001000000110011011111110100001111011101001010100110011101001101100100101010001011111110000110101100100000110111110111011101111100010001100011010101101100110110100101",
		/*.msg_size =*/		1944,
		/*.key =*/ 	(uint8_t*)"00110111111110011010101010111000001100010001101111",
		/*.result =*/ 	(uint8_t*)"00010011000011000101101001000001111001010011001111",
	}, { /* 2. From VedaPro int */
		/*.msg =*/ 	(uint8_t*)"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
		/*.msg_size =*/		1944,
		/*.key =*/ 	(uint8_t*)"01010101000010111110111000101001111111101110011011",
		/*.result =*/ 	(uint8_t*)"00111010101000111000101010001110011111101011011111",
	}, { /* NULL */
		/*.msg =*/ 		NULL,
		/*.msg_size =*/		0,
		/*.key =*/ 		NULL,
		/*.result =*/		NULL,
	}
};


static inline void
polyq50_cvt_bin(uint8_t *buf, size_t buf_size, uint8_t *bin) {
	static uint8_t *bin_tbl = (uint8_t*)"01";
	register uint8_t *buf_max, byte;

	for (buf_max = (buf + buf_size); buf < buf_max; buf ++) {
		byte = (*buf);
		(*bin ++) = bin_tbl[((byte >> 0) & 0x01)];
		(*bin ++) = bin_tbl[((byte >> 1) & 0x01)];
		(*bin ++) = bin_tbl[((byte >> 2) & 0x01)];
		(*bin ++) = bin_tbl[((byte >> 3) & 0x01)];
		(*bin ++) = bin_tbl[((byte >> 4) & 0x01)];
		(*bin ++) = bin_tbl[((byte >> 5) & 0x01)];
		(*bin ++) = bin_tbl[((byte >> 6) & 0x01)];
		(*bin ++) = bin_tbl[((byte >> 7) & 0x01)];
	}
	(*bin) = 0;
}

/* Import from little-endian hex string (L->H). */
static inline int
polyq50_import_le_bin(uint8_t *a, size_t count, uint8_t *buf, size_t buf_size) {
	register uint8_t *r_pos, *r_pos_max, *w_pos, *w_pos_max, cur_char, byte = 0;
	register size_t cnt;

	if (0 == count || 0 == buf_size)
		return (EINVAL);
	if ((count * sizeof(uint8_t)) < (buf_size / 8))
		return (EOVERFLOW);
	r_pos = buf;
	r_pos_max = (r_pos + buf_size);
	w_pos = (uint8_t*)a;
	w_pos_max = (w_pos + (count * sizeof(uint8_t)));

	for (cnt = 0; r_pos < r_pos_max; r_pos ++) {
		byte = (byte >> 1);
		cur_char = (*r_pos);
		if ('1' == cur_char) {
			byte |= (1 << 7);
		}
		cnt ++;
		if (8 > cnt) /* Wait untill 8 bit before write a byte. */
			continue;
		if (w_pos == w_pos_max)
			return (EOVERFLOW);
		(*w_pos ++) = byte;
		byte = 0;
		cnt = 0;
	}
	if (0 != cnt) { /* Last bits, less then byte. */
		byte = (byte >> (8 - cnt));
		if (w_pos == w_pos_max)
			return (EOVERFLOW);
		(*w_pos ++) = byte;
	}
	memset(w_pos, 0, (size_t)(w_pos_max - w_pos));
	return (0);
}


/* 0 - OK, non zero - error */
static inline int
polyq50_self_test() {
	int error = 0;
	size_t i, tm, msg_size;
	uint8_t	msg[POLYQ50_TEST_LEN];
	uint8_t	key[POLYQ50_TEST_LEN];
	uint8_t	result[POLYQ50_TEST_LEN];
	uint8_t	cresult[POLYQ50_TEST_LEN];
	uint8_t	tmpbuf[POLYQ50_TEST_LEN];


	for (i = 0; 0 != polyq50_tst1v[i].msg_size; i ++) {

		if (0 != polyq50_import_le_bin(msg, sizeof(msg),
		    polyq50_tst1v[i].msg, polyq50_tst1v[i].msg_size)) {
			polyq50_print("polyq50_import_le_bin(polyq50_tst1v[%zu].msg) fail!\n", i);
			error ++;
			continue;
		}
		msg_size = POLYQ50_BITS2BYTES(polyq50_tst1v[i].msg_size);
#if 0
		polyq50_cvt_bin(msg, msg_size, tmpbuf);
		polyq50_print("%zu: msg: %s\n", i, tmpbuf);
#endif
		if (0 != polyq50_import_le_bin(key, sizeof(key),
		    polyq50_tst1v[i].key, 50)) {
			polyq50_print("polyq50_import_le_bin(polyq50_tst1v[%zu].key) fail!\n", i);
			error ++;
			continue;
		}
		if (0 != polyq50_import_le_bin(result, sizeof(result),
		    polyq50_tst1v[i].result, 50)) {
			polyq50_print("polyq50_import_le_bin(polyq50_tst1v[%zu].result) fail!\n", i);
			error ++;
			continue;
		}
		tm = POLYQ50_BITS2BYTES(50);
		if (0 != polyq50_mac(msg, msg_size, key, cresult)) {
			polyq50_print("%zu polyq50_mac: SKIPPED!\n", i);
		} else {
			if (0 != memcmp(cresult, result, tm)) {
				polyq50_cvt_bin(cresult, tm, tmpbuf);
				polyq50_print("%zu polyq50_mac:      ERROR: \ncontrol:    %s\ncalculated: %s\n",
				    i, polyq50_tst1v[i].result, tmpbuf);
				error ++;
			} else {
				polyq50_print("%zu polyq50_mac:      OK!\n", i);
			}
		}
	}

	return (error);
}
#endif

#endif /* POLYQ50_H */
